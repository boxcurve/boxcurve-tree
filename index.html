<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Boxcurve Tree</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <link rel="stylesheet" href="src/assets/styles/main.css">
  <script src="src/config/config.js"></script>
</head>
<body>
  <div class="content">
    <!-- Empty content div for scrolling -->
  </div>

  <button class="toggle-panel" id="showPanel" style="display: block;">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M4 4H20V20H4V4Z" fill="#F04E23"/>
      <rect x="8" y="8" width="8" height="8" fill="white"/>
    </svg>
  </button>

  <div id="controlPanel" style="display: none;">
    <button class="hide-panel" id="hidePanel">Hide Controls</button>
    
    <div class="panel-header">
      <img src="logo-boxcurve.svg" alt="Boxcurve Logo" class="panel-logo">
      <h3 class="panel-title">Tree Control Panel</h3>
    </div>
    
    <div class="presets">
      <button id="preset1">Classic Tree</button>
      <button id="preset2">Spiral Galaxy</button>
      <button id="preset3">Static</button>
    </div>
    
    <div class="control-group">
      <h4>Tree Structure</h4>
      <div class="control-row">
        <span class="control-label">Max Depth:</span>
        <span class="control-value" id="maxDepthValue">7</span>
        <input type="number" id="maxDepthNumber" min="3" max="15" value="7" style="width: 60px; margin-right: 10px;">
        <input type="range" id="maxDepth" min="3" max="15" value="7">
      </div>
      <div class="control-row">
        <span class="control-label">Start Depth:</span>
        <span class="control-value" id="startDepthValue">2</span>
        <input type="number" id="startDepthNumber" min="1" max="5" value="2" style="width: 60px; margin-right: 10px;">
        <input type="range" id="startDepth" min="1" max="5" value="2">
      </div>
      <div class="control-row">
        <span class="control-label">Branch Angle:</span>
        <span class="control-value" id="branchAngleValue">35째</span>
        <input type="number" id="branchAngleNumber" min="10" max="80" value="35" style="width: 60px; margin-right: 10px;">
        <input type="range" id="branchAngle" min="10" max="80" value="35">
      </div>
      <div class="control-row">
        <span class="control-label">Auto-Change Angle:</span>
        <input type="checkbox" id="autoAngle" checked>
      </div>
      <div class="control-row">
        <span class="control-label">Angle Change Speed:</span>
        <span class="control-value" id="angleSpeedValue">0.3</span>
        <input type="number" id="angleSpeedNumber" min="0.1" max="3" step="0.1" value="0.3" style="width: 60px; margin-right: 10px;">
        <input type="range" id="angleSpeed" min="0.1" max="3" step="0.1" value="0.3">
      </div>
      <div class="control-row">
        <span class="control-label">Scale Factor:</span>
        <span class="control-value" id="scaleFactorValue">0.7</span>
        <input type="number" id="scaleFactorNumber" min="0.5" max="0.9" step="0.05" value="0.7" style="width: 60px; margin-right: 10px;">
        <input type="range" id="scaleFactor" min="0.5" max="0.9" step="0.05" value="0.7">
      </div>
    </div>
    
    <div class="control-group">
      <h4>Position & Size</h4>
      <div class="control-row">
        <span class="control-label">X Position:</span>
        <span class="control-value" id="xPositionValue">50%</span>
        <input type="number" id="xPositionNumber" min="10" max="90" value="50" style="width: 60px; margin-right: 10px;">
        <input type="range" id="xPosition" min="10" max="90" value="50">
      </div>
      <div class="control-row">
        <span class="control-label">Y Position:</span>
        <span class="control-value" id="yPositionValue">50%</span>
        <input type="number" id="yPositionNumber" min="10" max="90" value="50" style="width: 60px; margin-right: 10px;">
        <input type="range" id="yPosition" min="10" max="90" value="50">
      </div>
      <div class="control-row">
        <span class="control-label">Z Position:</span>
        <span class="control-value" id="zPositionValue">0</span>
        <input type="number" id="zPositionNumber" min="-200" max="200" value="0" style="width: 60px; margin-right: 10px;">
        <input type="range" id="zPosition" min="-200" max="200" value="0">
      </div>
      <div class="control-row">
        <span class="control-label">Auto-Move:</span>
        <input type="checkbox" id="autoMove" checked>
      </div>
      <div class="control-row">
        <span class="control-label">Movement Speed:</span>
        <span class="control-value" id="moveSpeedValue">0.1</span>
        <input type="number" id="moveSpeedNumber" min="0.1" max="3" step="0.1" value="0.1" style="width: 60px; margin-right: 10px;">
        <input type="range" id="moveSpeed" min="0.1" max="3" step="0.1" value="0.1">
      </div>
      <div class="control-row">
        <span class="control-label">Starting Size:</span>
        <span class="control-value" id="startingSizeValue">120</span>
        <input type="number" id="startingSizeNumber" min="50" max="200" value="120" style="width: 60px; margin-right: 10px;">
        <input type="range" id="startingSize" min="50" max="200" value="120">
      </div>
    </div>
    
    <!-- Rotation Control Group -->
    <div class="control-group">
      <h4>Rotation</h4>
      <div class="control-row">
        <span class="control-label">X-Axis Rotation:</span>
        <span class="control-value" id="rotationXValue">0째</span>
        <input type="number" id="rotationXNumber" min="-180" max="180" value="0" style="width: 60px; margin-right: 10px;">
        <input type="range" id="rotationX" min="-180" max="180" value="0">
      </div>
      <div class="control-row">
        <span class="control-label">Y-Axis Rotation:</span>
        <span class="control-value" id="rotationYValue">0째</span>
        <input type="number" id="rotationYNumber" min="-180" max="180" value="0" style="width: 60px; margin-right: 10px;">
        <input type="range" id="rotationY" min="-180" max="180" value="0">
      </div>
      <div class="control-row">
        <span class="control-label">Z-Axis Rotation:</span>
        <span class="control-value" id="rotationZValue">0째</span>
        <input type="number" id="rotationZNumber" min="-180" max="180" value="0" style="width: 60px; margin-right: 10px;">
        <input type="range" id="rotationZ" min="-180" max="180" value="0">
      </div>
      <div class="control-row">
        <span class="control-label">Auto-Rotate:</span>
        <input type="checkbox" id="autoRotate" checked>
      </div>
      <div class="control-row">
        <span class="control-label">Rotation Speed:</span>
        <span class="control-value" id="rotationSpeedValue">0.7</span>
        <input type="number" id="rotationSpeedNumber" min="0.1" max="5" step="0.1" value="0.7" style="width: 60px; margin-right: 10px;">
        <input type="range" id="rotationSpeed" min="0.1" max="5" step="0.1" value="0.7">
      </div>
    </div>
    
    <div class="control-group">
      <h4>Animation</h4>
      <div class="control-row">
        <span class="control-label">Max Zoom:</span>
        <span class="control-value" id="maxZoomValue">6.0</span>
        <input type="number" id="maxZoomNumber" min="1" max="10" step="0.1" value="6.0" style="width: 60px; margin-right: 10px;">
        <input type="range" id="maxZoom" min="1" max="10" step="0.1" value="6.0">
      </div>
      <div class="control-row">
        <span class="control-label">Zoom Speed:</span>
        <span class="control-value" id="zoomSpeedValue">0.1</span>
        <input type="number" id="zoomSpeedNumber" min="0.01" max="0.5" step="0.01" value="0.1" style="width: 60px; margin-right: 10px;">
        <input type="range" id="zoomSpeed" min="0.01" max="0.5" step="0.01" value="0.1">
      </div>
      <div class="control-row">
        <span class="control-label">Growth Start:</span>
        <span class="control-value" id="growthStartValue">2%</span>
        <input type="number" id="growthStartNumber" min="0" max="50" value="2" style="width: 60px; margin-right: 10px;">
        <input type="range" id="growthStart" min="0" max="50" value="2">
      </div>
      <div class="control-row">
        <span class="control-label">Growth End:</span>
        <span class="control-value" id="growthEndValue">100%</span>
        <input type="number" id="growthEndNumber" min="50" max="100" value="100" style="width: 60px; margin-right: 10px;">
        <input type="range" id="growthEnd" min="50" max="100" value="100">
      </div>
    </div>
    
    <div class="control-group">
      <h4>Colors</h4>
      <div class="control-row">
        <span class="control-label">Base Color:</span>
        <input type="color" id="baseColor" value="#142864">
        <span class="color-preview" style="background-color: #142864;"></span>
        <span id="baseColorHex" class="hex-value">#142864</span>
      </div>
      <div class="control-row">
        <span class="control-label">Main Brand Color:</span>
        <input type="color" id="brandColor" value="#F04E23">
        <span class="color-preview" style="background-color: #F04E23;"></span>
        <span id="brandColorHex" class="hex-value">#F04E23</span>
      </div>
      <div class="control-row">
        <span class="control-label">Fill Type:</span>
        <select id="fillType">
          <option value="gradient">Gradient</option>
          <option value="solid">Solid</option>
          <option value="outline">Outline Only</option>
          <option value="sidewalls">Side Walls Only</option>
        </select>
      </div>
      <div class="control-row">
        <span class="control-label">Stroke Weight:</span>
        <span class="control-value" id="strokeWeightValue">4</span>
        <input type="range" id="strokeWeight" min="1" max="5" value="4">
      </div>
    </div>
    
    <!-- New 3D Depth Control Group -->
    <div class="control-group">
      <h4>3D Depth Settings</h4>
      <div class="control-row">
        <span class="control-label">Pixel Depth:</span>
        <span class="control-value" id="pixelDepthValue">10</span>
        <input type="number" id="pixelDepthNumber" min="0" max="50" value="10" style="width: 60px; margin-right: 10px;">
        <input type="range" id="pixelDepth" min="0" max="50" value="10">
      </div>
      <div class="control-row">
        <span class="control-label">Auto Depth Variation:</span>
        <input type="checkbox" id="autoDepth" checked>
      </div>
      <div class="control-row">
        <span class="control-label">Depth by Level:</span>
        <input type="checkbox" id="depthByLevel" checked>
      </div>
    </div>
    
    <!-- New Lighting Control Group -->
    <div class="control-group">
      <h4>Lighting Settings</h4>
      <div class="control-row">
        <span class="control-label">Light Angle X:</span>
        <span class="control-value" id="lightAngleXValue">45째</span>
        <input type="number" id="lightAngleXNumber" min="-180" max="180" value="45" style="width: 60px; margin-right: 10px;">
        <input type="range" id="lightAngleX" min="-180" max="180" value="45">
      </div>
      <div class="control-row">
        <span class="control-label">Light Angle Y:</span>
        <span class="control-value" id="lightAngleYValue">45째</span>
        <input type="number" id="lightAngleYNumber" min="-180" max="180" value="45" style="width: 60px; margin-right: 10px;">
        <input type="range" id="lightAngleY" min="-180" max="180" value="45">
      </div>
      <div class="control-row">
        <span class="control-label">Light Intensity:</span>
        <span class="control-value" id="lightIntensityValue">80%</span>
        <input type="number" id="lightIntensityNumber" min="0" max="100" value="80" style="width: 60px; margin-right: 10px;">
        <input type="range" id="lightIntensity" min="0" max="100" value="80">
      </div>
      <div class="control-row">
        <span class="control-label">Enable Lighting:</span>
        <input type="checkbox" id="enableLighting" checked>
      </div>
    </div>
    
    <div class="metrics" id="metrics">
      <h4>Debug Information</h4>
      Current Depth: 2/12<br>
      Squares Drawn: 0<br>
      Render Time: 0ms<br>
      Zoom Factor: 1.00x<br>
      Scroll Progress: 0.0%<br>
      Branch Angle: 45째<br>
      Rotation X: 0째<br>
      Rotation Y: 0째
    </div>
    
    <!-- Export Controls -->
    <div class="control-group">
      <h4>Export Options</h4>
      <div class="control-row export-options">
        <button id="exportSVG" class="export-button">Export as SVG</button>
        <span id="exportStatus" class="export-status"></span>
      </div>
      <div class="control-row">
        <span class="control-label">Export Quality:</span>
        <select id="exportQuality">
          <option value="standard">Standard</option>
          <option value="high">High Resolution</option>
        </select>
      </div>
    </div>
  </div>

  <script>
    // Global p5.js instance
    let p5Instance;

    // Create a new p5 instance with our sketch
    window.addEventListener('load', function() {
      p5Instance = new p5(sketch);
    });

    // Define the sketch
    function sketch(p) {
      // ===== Runtime Variables =====
      let needsUpdate = true;
      let lastScrollY = 0;
      let lastMouseX, lastMouseY;
      let currentDepth = window.config.startDepth;
      let mirror = false;
      let zoomFactor = 1.0;
      let targetZoom = 1.0;
      let renderTime = 0;
      let squaresDrawn = 0;
      let lastFrameTime = 0;
      
      // Define intermediate colors for gradient
      const intermediateColors = [
        window.config.baseColor,
        [80, 30, 80],  // Purple
        [120, 40, 70], // Maroon
        [180, 60, 60], // Dark Red
        window.config.brandColor
      ];
      
      // Function to update intermediate colors when base or brand colors change
      function updateIntermediateColors() {
        intermediateColors[0] = window.config.baseColor;
        intermediateColors[4] = window.config.brandColor;
        needsUpdate = true;
      }
      
      p.setup = function() {
        const canvas = p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
        canvas.id('treeCanvas');
        
        // Initialize mouse position
        lastMouseX = p.mouseX;
        lastMouseY = p.mouseY;
        lastFrameTime = p.millis();
        
        // Load saved preset if available
        loadSavedPreset();
        
        // Update intermediate colors to match current config
        updateIntermediateColors();
        
        // Set up control panel event listeners
        setupControlPanel();
        
        // Set up panel visibility event listeners
        document.getElementById('hidePanel').addEventListener('click', function() {
          console.log('Hide panel clicked');
          document.getElementById('controlPanel').style.display = 'none';
          document.getElementById('showPanel').style.display = 'block';
        });
        
        document.getElementById('showPanel').addEventListener('click', function() {
          console.log('Show panel clicked');
          document.getElementById('controlPanel').style.display = 'block';
          document.getElementById('showPanel').style.display = 'none';
        });
        
        // Force first update
        needsUpdate = true;
        
        // Explicitly console log that initialization is complete
        console.log("Boxcurve Tree setup complete");
      };
      
      p.draw = function() {
        // Check for auto-rotation
        const currentTime = p.millis();
        const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
        lastFrameTime = currentTime;
        
        // Update auto-rotation, auto-movement, and auto-angle if enabled
        if (window.config.autoRotate || window.config.autoMove || window.config.autoAngle || window.config.autoDepth) {
          if (window.config.autoRotate) {
            // Rotate primarily around Y axis, but also slightly around Z for a more interesting effect
            window.config.rotationY += window.config.rotationSpeed * deltaTime * 15;
            window.config.rotationZ += window.config.rotationSpeed * deltaTime * 5;
            
            // Keep angles within -180 to 180 range
            if (window.config.rotationY > 180) window.config.rotationY -= 360;
            if (window.config.rotationZ > 180) window.config.rotationZ -= 360;
            
            // Update UI sliders to reflect current rotation values
            document.getElementById('rotationY').value = window.config.rotationY;
            document.getElementById('rotationYValue').textContent = Math.round(window.config.rotationY) + '째';
            
            document.getElementById('rotationZ').value = window.config.rotationZ;
            document.getElementById('rotationZValue').textContent = Math.round(window.config.rotationZ) + '째';
          }
          
          if (window.config.autoMove) {
            // Update movement phase
            window.config.movePhase += window.config.moveSpeed * deltaTime;
            if (window.config.movePhase > Math.PI * 2) window.config.movePhase -= Math.PI * 2;
            
            // Create smooth movement patterns
            const xRange = 30; // Range of movement in percentage
            const yRange = 8; // Significantly reduced y-range to eliminate jumps
            const zRange = 100;
            
            // Calculate new positions using sine and cosine for smooth orbiting motion
            const newX = 50 + xRange * Math.sin(window.config.movePhase);
            const newY = 50 + yRange * Math.cos(window.config.movePhase * 0.3); // Much slower frequency for Y
            const newZ = zRange * Math.sin(window.config.movePhase * 0.5);
            
            // Use separate lerp factors for X/Z vs Y for better control
            const xzLerpFactor = Math.min(0.05 * (60 * deltaTime), 0.2);
            const yLerpFactor = Math.min(0.02 * (60 * deltaTime), 0.08); // Much gentler for Y
            
            // Apply movement with separate smoothing for each axis
            window.config.xPosition = window.config.xPosition + (newX - window.config.xPosition) * xzLerpFactor;
            window.config.yPosition = window.config.yPosition + (newY - window.config.yPosition) * yLerpFactor;
            window.config.zPosition = window.config.zPosition + (newZ - window.config.zPosition) * xzLerpFactor;
            
            // Update UI sliders to reflect current position values
            // Only update UI every few frames to reduce performance impact
            if (p.frameCount % 5 === 0) {
              document.getElementById('xPosition').value = Math.round(window.config.xPosition);
              document.getElementById('xPositionValue').textContent = Math.round(window.config.xPosition) + '%';
              
              document.getElementById('yPosition').value = Math.round(window.config.yPosition);
              document.getElementById('yPositionValue').textContent = Math.round(window.config.yPosition) + '%';
              
              document.getElementById('zPosition').value = Math.round(window.config.zPosition);
              document.getElementById('zPositionValue').textContent = Math.round(window.config.zPosition);
            }
          }
          
          if (window.config.autoAngle) {
            // Update angle phase
            window.config.anglePhase += window.config.angleSpeed * deltaTime;
            if (window.config.anglePhase > Math.PI * 2) window.config.anglePhase -= Math.PI * 2;
            
            // Create smooth angle oscillation between min and max values
            const minAngle = 15;
            const maxAngle = 75;
            const range = maxAngle - minAngle;
            
            // Use sine wave to smoothly oscillate between min and max angle
            const newAngle = minAngle + range * (0.5 + 0.5 * Math.sin(window.config.anglePhase));
            
            // Apply new angle
            window.config.branchAngle = newAngle;
            
            // Update UI slider to reflect current angle value
            document.getElementById('branchAngle').value = Math.round(newAngle);
            document.getElementById('branchAngleValue').textContent = Math.round(newAngle) + '째';
          }
          
          // New code for auto-depth
          if (window.config.autoDepth) {
            // Update depth phase
            window.config.depthPhase += 0.2 * deltaTime;
            if (window.config.depthPhase > Math.PI * 2) window.config.depthPhase -= Math.PI * 2;
            
            // Create smooth depth oscillation
            const minDepth = 5;
            const maxDepth = 25;
            const rangeDepth = maxDepth - minDepth;
            
            // Use sine wave to smoothly oscillate between min and max depth
            const newDepth = minDepth + rangeDepth * (0.5 + 0.5 * Math.sin(window.config.depthPhase));
            
            // Apply new depth
            window.config.pixelDepth = newDepth;
            
            // Update UI slider to reflect current depth value
            document.getElementById('pixelDepth').value = Math.round(newDepth);
            document.getElementById('pixelDepthValue').textContent = Math.round(newDepth);
          }
          
          needsUpdate = true;
        }
        
        if (!needsUpdate) return;
        
        const startTime = performance.now();
        squaresDrawn = 0;
        
        p.clear();
        
        // Map scroll position to determine depth and zoom
        const scrollProgress = p.constrain(window.scrollY / (document.body.scrollHeight - p.windowHeight), 0, 1);
        
        // Calculate the effective scroll progress for tree growth
        const growthRange = window.config.growthEnd - window.config.growthStart;
        const normalizedScrollProgress = p.constrain(
          p.map(scrollProgress * 100, window.config.growthStart, window.config.growthEnd, 0, 1), 
          0, 
          1
        );
        
        // Map normalized scroll progress to determine depth
        currentDepth = p.floor(p.map(normalizedScrollProgress, 0, 1, window.config.startDepth, window.config.maxDepth));
        
        // Calculate target zoom based on scroll
        targetZoom = p.map(scrollProgress, 0, 1, 1.0, window.config.maxZoom);
        
        // Smoothly adjust zoom
        zoomFactor += (targetZoom - zoomFactor) * window.config.zoomSpeed;
        
        // Ensure zoom is exactly 1.0 when at the top of the page (with a small tolerance)
        if (scrollProgress < 0.01) {
          zoomFactor = p.lerp(zoomFactor, 1.0, 0.1);  // Faster convergence to 1.0 when near top
          if (Math.abs(zoomFactor - 1.0) < 0.01) {
            zoomFactor = 1.0;  // Snap to exactly 1.0 when very close
          }
        }
        
        p.push();
        
        // Calculate the position in screen coordinates
        const xPos = p.map(window.config.xPosition, 0, 100, -p.width/2, p.width/2);
        const yPos = p.map(window.config.yPosition, 0, 100, -p.height/2, p.height/2);
        
        // Apply position
        p.translate(xPos, yPos, window.config.zPosition);
        
        // Apply rotations
        p.rotateX(p.radians(window.config.rotationX));
        p.rotateY(p.radians(window.config.rotationY));
        p.rotateZ(p.radians(window.config.rotationZ));
        
        // Scale based on zoom factor
        p.scale(zoomFactor);
        
        // Draw the tree
        drawBoxcurveTree(0, 0, window.config.startingSize, currentDepth, scrollProgress);
        
        p.pop();
        
        // Update render time
        renderTime = performance.now() - startTime;
        
        // Update metrics in the control panel
        updateMetrics(scrollProgress);
        
        // Mark update as complete
        needsUpdate = false;
        
        // Log success
        if (squaresDrawn > 0) {
          console.log(`Frame rendered with ${squaresDrawn} squares`);
        }
      };
      
      function drawBoxcurveTree(x, y, size, depth, scrollProgress) {
        p.push();
        p.translate(x, y);
        
        if (depth > 0) {
          const p1 = [-size / 2, -size / 2];
          const p2 = [size / 2, -size / 2];
          generateTree([p1, p2], 0, depth, scrollProgress);
        }
        
        p.pop();
      }
      
      function generateTree(coordSet, depth, maxDepth, scrollProgress) {
        if (depth >= maxDepth) return;
        
        const p1 = coordSet[0];
        const p2 = coordSet[1];
        
        // Draw the cube (square)
        const cubeCoordSet = drawCube(p1, p2, depth, scrollProgress);
        
        // Calculate next squares
        const size = p.dist(p1[0], p1[1], p2[0], p2[1]);
        const nextSize = size * window.config.scaleFactor;
        
        // Draw the triangle for branch connection
        const triangleCoordSets = drawTriangle(cubeCoordSet[0], cubeCoordSet[1], depth, window.config.branchAngle, mirror, scrollProgress);
        
        // Continue with recursion for next branches
        for (let nextCoordSet of triangleCoordSets) {
          generateTree(nextCoordSet, depth + 1, maxDepth, scrollProgress);
        }
      }
      
      function drawCube(p1, p2, depth, scrollProgress) {
        // Calculate the other two points of the square
        const p1_to_p2 = [p1[0] - p2[0], p1[1] - p2[1]];
        const p1_to_p4 = [-p1_to_p2[1], p1_to_p2[0]];
        
        const p3 = [p2[0] + p1_to_p4[0], p2[1] + p1_to_p4[1]];
        const p4 = [p1[0] + p1_to_p4[0], p1[1] + p1_to_p4[1]];
        
        // Get style based on settings
        const style = getStyle(depth, "cube", scrollProgress);
        
        // Calculate actual depth based on settings
        let actualDepth = window.config.pixelDepth;
        
        // Vary depth by level if enabled
        if (window.config.depthByLevel) {
          actualDepth = window.config.pixelDepth * (1.0 - (depth / window.config.maxDepth) * 0.5);
        }
        
        // Calculate lighting effect if enabled
        let shadeFactor = 1.0;
        
        if (window.config.enableLighting) {
          // Convert light angles to radians
          const lightX = p.radians(window.config.lightAngleX);
          const lightY = p.radians(window.config.lightAngleY);
          
          // Calculate light direction vector (simplified)
          const lightDirX = Math.cos(lightY) * Math.sin(lightX);
          const lightDirY = Math.sin(lightY);
          const lightDirZ = Math.cos(lightY) * Math.cos(lightX);
          
          // We'll use a simple directional lighting model
          // The face normal is just (0, 0, 1) for the front face
          const dotProduct = lightDirZ; // Simplified dot product for front face
          
          // Map the dot product to shade
          const lightIntensityFactor = window.config.lightIntensity / 100;
          shadeFactor = 0.3 + 0.7 * Math.max(0, dotProduct) * lightIntensityFactor;
        }
        
        // Only draw the front face if not using sidewalls only style
        if (style.fillType !== 'sidewalls') {
          // Draw the 3D cube - first the front face
          p.beginShape();
          
          // Set fill color if specified
          if (style.fill) {
            const r = style.fill[0] * shadeFactor;
            const g = style.fill[1] * shadeFactor;
            const b = style.fill[2] * shadeFactor;
            p.fill(r, g, b);
          } else {
            p.noFill();
          }
          
          // Set stroke if specified
          if (style.outline) {
            if (style.outline.length > 3) {
              p.stroke(style.outline[0], style.outline[1], style.outline[2], style.outline[3]);
            } else {
              p.stroke(style.outline[0], style.outline[1], style.outline[2]);
            }
            p.strokeWeight(window.config.strokeWeight);
          } else {
            p.noStroke();
          }
          
          // Front face
          p.vertex(p1[0], p1[1], 0);
          p.vertex(p2[0], p2[1], 0);
          p.vertex(p3[0], p3[1], 0);
          p.vertex(p4[0], p4[1], 0);
          p.endShape(p.CLOSE);
        }
        
        // Only draw the other faces if we have actual depth
        if (actualDepth > 0) {
          // Calculate back points
          const backZ = -actualDepth;
          
          // Calculate darker shade for side faces
          const sideShadeFactor = shadeFactor * 0.8; // Make sides slightly darker
          
          // Side faces (only if the cube has depth)
          // Left face
          p.beginShape();
          if (style.fill) {
            const r = style.fill[0] * sideShadeFactor;
            const g = style.fill[1] * sideShadeFactor;
            const b = style.fill[2] * sideShadeFactor;
            p.fill(r, g, b);
          }
          p.vertex(p1[0], p1[1], 0);
          p.vertex(p4[0], p4[1], 0);
          p.vertex(p4[0], p4[1], backZ);
          p.vertex(p1[0], p1[1], backZ);
          p.endShape(p.CLOSE);
          
          // Right face
          p.beginShape();
          p.vertex(p2[0], p2[1], 0);
          p.vertex(p3[0], p3[1], 0);
          p.vertex(p3[0], p3[1], backZ);
          p.vertex(p2[0], p2[1], backZ);
          p.endShape(p.CLOSE);
          
          // Top face
          p.beginShape();
          const topShadeFactor = shadeFactor * 0.9; // Slightly darker
          if (style.fill) {
            const r = style.fill[0] * topShadeFactor;
            const g = style.fill[1] * topShadeFactor;
            const b = style.fill[2] * topShadeFactor;
            p.fill(r, g, b);
          }
          p.vertex(p1[0], p1[1], 0);
          p.vertex(p2[0], p2[1], 0);
          p.vertex(p2[0], p2[1], backZ);
          p.vertex(p1[0], p1[1], backZ);
          p.endShape(p.CLOSE);
          
          // Bottom face
          p.beginShape();
          p.vertex(p4[0], p4[1], 0);
          p.vertex(p3[0], p3[1], 0);
          p.vertex(p3[0], p3[1], backZ);
          p.vertex(p4[0], p4[1], backZ);
          p.endShape(p.CLOSE);
          
          // Only draw the back face if not using sidewalls only style
          if (style.fillType !== 'sidewalls') {
            // Back face
            p.beginShape();
            const backShadeFactor = shadeFactor * 0.7; // Make back face darker
            if (style.fill) {
              const r = style.fill[0] * backShadeFactor;
              const g = style.fill[1] * backShadeFactor;
              const b = style.fill[2] * backShadeFactor;
              p.fill(r, g, b);
            }
            p.vertex(p1[0], p1[1], backZ);
            p.vertex(p2[0], p2[1], backZ);
            p.vertex(p3[0], p3[1], backZ);
            p.vertex(p4[0], p4[1], backZ);
            p.endShape(p.CLOSE);
          }
        }
        
        squaresDrawn++;
        
        return [p3, p4];
      }
      
      function drawTriangle(p1, p2, depth, angle, mirror, scrollProgress) {
        // Convert angle to radians
        let angle1 = p.PI * ((90 - angle) / 180);
        let angle2 = p.PI * (angle / 180);
        
        if (mirror) {
          [angle1, angle2] = [angle2, angle1];
        }
        
        const angle3 = p.PI - angle1 - angle2;
        
        // Calculate vectors and lengths
        const p1_to_p2 = [p2[0] - p1[0], p2[1] - p1[1]];
        const length_p1_to_p2 = Math.sqrt(p1_to_p2[0] * p1_to_p2[0] + p1_to_p2[1] * p1_to_p2[1]);
        const length_p1_to_p3 = length_p1_to_p2 * Math.sin(angle2) / Math.sin(angle3);
        
        const x = p1_to_p2[0];
        const y = p1_to_p2[1];
        
        // Calculate third point using the equations
        const equation_1 = p1[0] * x + p1[1] * y + length_p1_to_p3 * length_p1_to_p2 * Math.cos(angle1);
        const equation_2 = p2[1] * x - p2[0] * y + length_p1_to_p3 * length_p1_to_p2 * Math.sin(angle1);
        
        const factor = 1 / (length_p1_to_p2 * length_p1_to_p2);
        const x3 = factor * (x * equation_1 - y * equation_2);
        const y3 = factor * (y * equation_1 + x * equation_2);
        
        const p3 = [x3, y3];
        
        // Return the coordinates for the next branches
        return [[p3, p1], [p2, p3]];
      }
      
      function getStyle(depth, shape, scrollProgress) {
        // Determine color based on depth and settings
        let fillColor, outlineColor;
        
        switch(window.config.fillType) {
          case 'outline':
            // Just outlines, no fill
            fillColor = null;
            outlineColor = window.config.brandColor;
            break;
            
          case 'solid':
            // Solid fill based on depth
            fillColor = (depth === 0) ? window.config.baseColor : window.config.brandColor;
            outlineColor = null;
            break;
            
          case 'sidewalls':
            // Side walls only - use fill color but no outline
            fillColor = (depth === 0) ? window.config.baseColor : window.config.brandColor;
            outlineColor = window.config.brandColor; // Still need outline for the edges
            break;
            
          case 'gradient':
          default:
            // Gradient fill based on depth
            const colorIndex = p.constrain(p.map(depth, 0, window.config.maxDepth, 0, intermediateColors.length - 1), 0, intermediateColors.length - 1);
            const lowerIndex = p.floor(colorIndex);
            const upperIndex = p.ceil(colorIndex);
            const blendFactor = colorIndex - lowerIndex;
            
            if (lowerIndex === upperIndex) {
              fillColor = intermediateColors[lowerIndex];
            } else {
              // Blend between colors
              fillColor = [
                p.lerp(intermediateColors[lowerIndex][0], intermediateColors[upperIndex][0], blendFactor),
                p.lerp(intermediateColors[lowerIndex][1], intermediateColors[upperIndex][1], blendFactor),
                p.lerp(intermediateColors[lowerIndex][2], intermediateColors[upperIndex][2], blendFactor)
              ];
            }
            
            // Progressively remove outline as we scroll
            const outlineOpacity = p.map(scrollProgress, 0.3, 0.7, 255, 0);
            outlineColor = (outlineOpacity > 0) ? [...window.config.brandColor, outlineOpacity] : null;
            break;
        }
        
        return {
          fill: fillColor,
          outline: outlineColor,
          fillType: window.config.fillType // Pass the fill type to use in drawCube function
        };
      }
      
      p.windowResized = function() {
        p.resizeCanvas(p.windowWidth, p.windowHeight);
        needsUpdate = true;
      };
      
      function updateMetrics(scrollProgress) {
        const metricsElem = document.getElementById('metrics');
        
        metricsElem.innerHTML = `
          <h4>Debug Information</h4>
          Current Depth: ${currentDepth}/${window.config.maxDepth}<br>
          Squares Drawn: ${squaresDrawn}<br>
          Render Time: ${renderTime.toFixed(2)}ms<br>
          Zoom Factor: ${zoomFactor.toFixed(2)}x<br>
          Scroll Progress: ${(scrollProgress * 100).toFixed(1)}%<br>
          Growth: ${window.config.growthStart}% to ${window.config.growthEnd}%<br>
          Branch Angle: ${Math.round(window.config.branchAngle)}째 (Auto: ${window.config.autoAngle ? "On" : "Off"})<br>
          Position: X:${Math.round(window.config.xPosition)}%, Y:${Math.round(window.config.yPosition)}%, Z:${Math.round(window.config.zPosition)} (Auto: ${window.config.autoMove ? "On" : "Off"})<br>
          Rotation: X:${Math.round(window.config.rotationX)}째, Y:${Math.round(window.config.rotationY)}째, Z:${Math.round(window.config.rotationZ)}째 (Auto: ${window.config.autoRotate ? "On" : "Off"})<br>
          Pixel Depth: ${Math.round(window.config.pixelDepth)} (Auto: ${window.config.autoDepth ? "On" : "Off"})<br>
          Light Angle: X:${Math.round(window.config.lightAngleX)}째, Y:${Math.round(window.config.lightAngleY)}째 (Intensity: ${window.config.lightIntensity}%)
        `;
      }
      
      // Event listeners
      window.addEventListener('scroll', function() {
        needsUpdate = true;
        lastScrollY = window.scrollY;
      });
      
      function setupControlPanel() {
        // Set up preset buttons
        document.getElementById('preset1').addEventListener('click', function() {
          applyPreset('preset1');
        });
        
        document.getElementById('preset2').addEventListener('click', function() {
          applyPreset('preset2');
        });
        
        document.getElementById('preset3').addEventListener('click', function() {
          applyPreset('preset3');
        });
        
        // Tree Structure controls
        document.getElementById('maxDepth').addEventListener('input', function() {
          window.config.maxDepth = parseInt(this.value);
          document.getElementById('maxDepthValue').textContent = this.value;
          document.getElementById('maxDepthNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('maxDepthNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 3 && value <= 15) {
            window.config.maxDepth = value;
            document.getElementById('maxDepthValue').textContent = value;
            document.getElementById('maxDepth').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('startDepth').addEventListener('input', function() {
          window.config.startDepth = parseInt(this.value);
          document.getElementById('startDepthValue').textContent = this.value;
          document.getElementById('startDepthNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('startDepthNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 1 && value <= 5) {
            window.config.startDepth = value;
            document.getElementById('startDepthValue').textContent = value;
            document.getElementById('startDepth').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('branchAngle').addEventListener('input', function() {
          window.config.branchAngle = parseInt(this.value);
          document.getElementById('branchAngleValue').textContent = this.value + '째';
          document.getElementById('branchAngleNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('branchAngleNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 10 && value <= 80) {
            window.config.branchAngle = value;
            document.getElementById('branchAngleValue').textContent = value + '째';
            document.getElementById('branchAngle').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('angleSpeed').addEventListener('input', function() {
          window.config.angleSpeed = parseFloat(this.value);
          document.getElementById('angleSpeedValue').textContent = this.value;
          document.getElementById('angleSpeedNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('angleSpeedNumber').addEventListener('input', function() {
          const value = parseFloat(this.value);
          if (value >= 0.1 && value <= 3) {
            window.config.angleSpeed = value;
            document.getElementById('angleSpeedValue').textContent = value;
            document.getElementById('angleSpeed').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('scaleFactor').addEventListener('input', function() {
          window.config.scaleFactor = parseFloat(this.value);
          document.getElementById('scaleFactorValue').textContent = this.value;
          document.getElementById('scaleFactorNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('scaleFactorNumber').addEventListener('input', function() {
          const value = parseFloat(this.value);
          if (value >= 0.5 && value <= 0.9) {
            window.config.scaleFactor = value;
            document.getElementById('scaleFactorValue').textContent = value;
            document.getElementById('scaleFactor').value = value;
            needsUpdate = true;
          }
        });
        
        // Auto-Angle checkbox
        document.getElementById('autoAngle').addEventListener('change', function() {
          window.config.autoAngle = this.checked;
          needsUpdate = true;
        });
        
        // Rotation controls
        document.getElementById('rotationX').addEventListener('input', function() {
          window.config.rotationX = parseInt(this.value);
          document.getElementById('rotationXValue').textContent = this.value + '째';
          document.getElementById('rotationXNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('rotationXNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= -180 && value <= 180) {
            window.config.rotationX = value;
            document.getElementById('rotationXValue').textContent = value + '째';
            document.getElementById('rotationX').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('rotationY').addEventListener('input', function() {
          window.config.rotationY = parseInt(this.value);
          document.getElementById('rotationYValue').textContent = this.value + '째';
          document.getElementById('rotationYNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('rotationYNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= -180 && value <= 180) {
            window.config.rotationY = value;
            document.getElementById('rotationYValue').textContent = value + '째';
            document.getElementById('rotationY').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('rotationZ').addEventListener('input', function() {
          window.config.rotationZ = parseInt(this.value);
          document.getElementById('rotationZValue').textContent = this.value + '째';
          document.getElementById('rotationZNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('rotationZNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= -180 && value <= 180) {
            window.config.rotationZ = value;
            document.getElementById('rotationZValue').textContent = value + '째';
            document.getElementById('rotationZ').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('rotationSpeed').addEventListener('input', function() {
          window.config.rotationSpeed = parseFloat(this.value);
          document.getElementById('rotationSpeedValue').textContent = this.value;
          document.getElementById('rotationSpeedNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('rotationSpeedNumber').addEventListener('input', function() {
          const value = parseFloat(this.value);
          if (value >= 0.1 && value <= 5) {
            window.config.rotationSpeed = value;
            document.getElementById('rotationSpeedValue').textContent = value;
            document.getElementById('rotationSpeed').value = value;
            needsUpdate = true;
          }
        });
        
        // Auto-Rotate checkbox
        document.getElementById('autoRotate').addEventListener('change', function() {
          window.config.autoRotate = this.checked;
          needsUpdate = true;
        });
        
        // Animation controls
        document.getElementById('maxZoom').addEventListener('input', function() {
          window.config.maxZoom = parseFloat(this.value);
          document.getElementById('maxZoomValue').textContent = this.value;
          document.getElementById('maxZoomNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('maxZoomNumber').addEventListener('input', function() {
          const value = parseFloat(this.value);
          if (value >= 1 && value <= 10) {
            window.config.maxZoom = value;
            document.getElementById('maxZoomValue').textContent = value;
            document.getElementById('maxZoom').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('zoomSpeed').addEventListener('input', function() {
          window.config.zoomSpeed = parseFloat(this.value);
          document.getElementById('zoomSpeedValue').textContent = this.value;
          document.getElementById('zoomSpeedNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('zoomSpeedNumber').addEventListener('input', function() {
          const value = parseFloat(this.value);
          if (value >= 0.01 && value <= 0.5) {
            window.config.zoomSpeed = value;
            document.getElementById('zoomSpeedValue').textContent = value;
            document.getElementById('zoomSpeed').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('growthStart').addEventListener('input', function() {
          window.config.growthStart = parseInt(this.value);
          if (window.config.growthStart >= window.config.growthEnd) {
            window.config.growthStart = window.config.growthEnd - 5;
            this.value = window.config.growthStart;
          }
          document.getElementById('growthStartValue').textContent = this.value + '%';
          document.getElementById('growthStartNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('growthStartNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 0 && value <= 50 && value < window.config.growthEnd) {
            window.config.growthStart = value;
            document.getElementById('growthStartValue').textContent = value + '%';
            document.getElementById('growthStart').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('growthEnd').addEventListener('input', function() {
          window.config.growthEnd = parseInt(this.value);
          if (window.config.growthEnd <= window.config.growthStart) {
            window.config.growthEnd = window.config.growthStart + 5;
            this.value = window.config.growthEnd;
          }
          document.getElementById('growthEndValue').textContent = this.value + '%';
          document.getElementById('growthEndNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('growthEndNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 50 && value <= 100 && value > window.config.growthStart) {
            window.config.growthEnd = value;
            document.getElementById('growthEndValue').textContent = value + '%';
            document.getElementById('growthEnd').value = value;
            needsUpdate = true;
          }
        });
        
        // Position and size controls
        document.getElementById('xPosition').addEventListener('input', function() {
          window.config.xPosition = parseInt(this.value);
          document.getElementById('xPositionValue').textContent = this.value + '%';
          document.getElementById('xPositionNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('xPositionNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 10 && value <= 90) {
            window.config.xPosition = value;
            document.getElementById('xPositionValue').textContent = value + '%';
            document.getElementById('xPosition').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('yPosition').addEventListener('input', function() {
          window.config.yPosition = parseInt(this.value);
          document.getElementById('yPositionValue').textContent = this.value + '%';
          document.getElementById('yPositionNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('yPositionNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 10 && value <= 90) {
            window.config.yPosition = value;
            document.getElementById('yPositionValue').textContent = value + '%';
            document.getElementById('yPosition').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('zPosition').addEventListener('input', function() {
          window.config.zPosition = parseInt(this.value);
          document.getElementById('zPositionValue').textContent = this.value;
          document.getElementById('zPositionNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('zPositionNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= -200 && value <= 200) {
            window.config.zPosition = value;
            document.getElementById('zPositionValue').textContent = value;
            document.getElementById('zPosition').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('moveSpeed').addEventListener('input', function() {
          window.config.moveSpeed = parseFloat(this.value);
          document.getElementById('moveSpeedValue').textContent = this.value;
          document.getElementById('moveSpeedNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('moveSpeedNumber').addEventListener('input', function() {
          const value = parseFloat(this.value);
          if (value >= 0.1 && value <= 3) {
            window.config.moveSpeed = value;
            document.getElementById('moveSpeedValue').textContent = value;
            document.getElementById('moveSpeed').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('startingSize').addEventListener('input', function() {
          window.config.startingSize = parseInt(this.value);
          document.getElementById('startingSizeValue').textContent = this.value;
          document.getElementById('startingSizeNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('startingSizeNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 50 && value <= 200) {
            window.config.startingSize = value;
            document.getElementById('startingSizeValue').textContent = value;
            document.getElementById('startingSize').value = value;
            needsUpdate = true;
          }
        });
        
        // Auto-Move checkbox
        document.getElementById('autoMove').addEventListener('change', function() {
          window.config.autoMove = this.checked;
          needsUpdate = true;
        });
        
        // Color controls
        document.getElementById('baseColor').addEventListener('input', function() {
          const hex = this.value;
          window.config.baseColor = [
            parseInt(hex.slice(1, 3), 16),
            parseInt(hex.slice(3, 5), 16),
            parseInt(hex.slice(5, 7), 16)
          ];
          this.nextElementSibling.style.backgroundColor = hex;
          document.getElementById('baseColorHex').textContent = hex.toUpperCase();
          updateIntermediateColors();
          needsUpdate = true;
        });
        
        document.getElementById('brandColor').addEventListener('input', function() {
          const hex = this.value;
          window.config.brandColor = [
            parseInt(hex.slice(1, 3), 16),
            parseInt(hex.slice(3, 5), 16),
            parseInt(hex.slice(5, 7), 16)
          ];
          this.nextElementSibling.style.backgroundColor = hex;
          document.getElementById('brandColorHex').textContent = hex.toUpperCase();
          updateIntermediateColors();
          needsUpdate = true;
        });
        
        document.getElementById('fillType').addEventListener('change', function() {
          window.config.fillType = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('strokeWeight').addEventListener('input', function() {
          window.config.strokeWeight = parseInt(this.value);
          document.getElementById('strokeWeightValue').textContent = this.value;
          needsUpdate = true;
        });
        
        // New 3D Depth controls
        document.getElementById('pixelDepth').addEventListener('input', function() {
          window.config.pixelDepth = parseInt(this.value);
          document.getElementById('pixelDepthValue').textContent = this.value;
          document.getElementById('pixelDepthNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('pixelDepthNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 0 && value <= 50) {
            window.config.pixelDepth = value;
            document.getElementById('pixelDepthValue').textContent = value;
            document.getElementById('pixelDepth').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('autoDepth').addEventListener('change', function() {
          window.config.autoDepth = this.checked;
          needsUpdate = true;
        });
        
        document.getElementById('depthByLevel').addEventListener('change', function() {
          window.config.depthByLevel = this.checked;
          needsUpdate = true;
        });
        
        // New Lighting controls
        document.getElementById('lightAngleX').addEventListener('input', function() {
          window.config.lightAngleX = parseInt(this.value);
          document.getElementById('lightAngleXValue').textContent = this.value + '째';
          document.getElementById('lightAngleXNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('lightAngleXNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= -180 && value <= 180) {
            window.config.lightAngleX = value;
            document.getElementById('lightAngleXValue').textContent = value + '째';
            document.getElementById('lightAngleX').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('lightAngleY').addEventListener('input', function() {
          window.config.lightAngleY = parseInt(this.value);
          document.getElementById('lightAngleYValue').textContent = this.value + '째';
          document.getElementById('lightAngleYNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('lightAngleYNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= -180 && value <= 180) {
            window.config.lightAngleY = value;
            document.getElementById('lightAngleYValue').textContent = value + '째';
            document.getElementById('lightAngleY').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('lightIntensity').addEventListener('input', function() {
          window.config.lightIntensity = parseInt(this.value);
          document.getElementById('lightIntensityValue').textContent = this.value + '%';
          document.getElementById('lightIntensityNumber').value = this.value;
          needsUpdate = true;
        });
        
        document.getElementById('lightIntensityNumber').addEventListener('input', function() {
          const value = parseInt(this.value);
          if (value >= 0 && value <= 100) {
            window.config.lightIntensity = value;
            document.getElementById('lightIntensityValue').textContent = value + '%';
            document.getElementById('lightIntensity').value = value;
            needsUpdate = true;
          }
        });
        
        document.getElementById('enableLighting').addEventListener('change', function() {
          window.config.enableLighting = this.checked;
          needsUpdate = true;
        });
        
        // Export SVG button
        document.getElementById('exportSVG').addEventListener('click', function() {
          exportTreeAsSVG();
        });
        
        // Log that controls are set up
        console.log("Control panel setup complete");
      }
      
      // Function to apply a preset
      function applyPreset(presetKey) {
        if (!window.presets[presetKey]) {
          console.error('Preset not found:', presetKey);
          return;
        }
        
        console.log(`Applying preset: ${window.presets[presetKey].name}`);
        
        // Save the chosen preset to localStorage
        localStorage.setItem('boxcurveTreePreset', presetKey);
        
        // Apply the preset configuration
        const preset = window.presets[presetKey];
        for (const key in preset) {
          if (key !== 'name' && key in window.config) {
            window.config[key] = preset[key];
          }
        }
        
        // Update intermediate colors after changing baseColor and brandColor
        updateIntermediateColors();
        
        // Update all UI controls to match the preset
        updateUIFromConfig();
        
        // Trigger update
        needsUpdate = true;
      }
      
      // Function to load saved preset
      function loadSavedPreset() {
        const savedPreset = localStorage.getItem('boxcurveTreePreset');
        if (savedPreset && window.presets[savedPreset]) {
          applyPreset(savedPreset);
          console.log(`Loaded saved preset: ${window.presets[savedPreset].name}`);
        } else {
          // If no preset is saved, use the Static preset as default
          applyPreset('preset3');
          console.log(`No saved preset found. Using default preset: ${window.presets.preset3.name}`);
        }
      }
      
      // Function to update all UI controls based on current config
      function updateUIFromConfig() {
        // Tree Structure
        document.getElementById('maxDepth').value = window.config.maxDepth;
        document.getElementById('maxDepthValue').textContent = window.config.maxDepth;
        document.getElementById('maxDepthNumber').value = window.config.maxDepth;
        
        document.getElementById('startDepth').value = window.config.startDepth;
        document.getElementById('startDepthValue').textContent = window.config.startDepth;
        document.getElementById('startDepthNumber').value = window.config.startDepth;
        
        document.getElementById('branchAngle').value = window.config.branchAngle;
        document.getElementById('branchAngleValue').textContent = window.config.branchAngle + '째';
        document.getElementById('branchAngleNumber').value = window.config.branchAngle;
        
        document.getElementById('autoAngle').checked = window.config.autoAngle;
        
        document.getElementById('angleSpeed').value = window.config.angleSpeed;
        document.getElementById('angleSpeedValue').textContent = window.config.angleSpeed;
        document.getElementById('angleSpeedNumber').value = window.config.angleSpeed;
        
        document.getElementById('scaleFactor').value = window.config.scaleFactor;
        document.getElementById('scaleFactorValue').textContent = window.config.scaleFactor;
        document.getElementById('scaleFactorNumber').value = window.config.scaleFactor;
        
        // Rotation
        document.getElementById('rotationX').value = window.config.rotationX;
        document.getElementById('rotationXValue').textContent = window.config.rotationX + '째';
        document.getElementById('rotationXNumber').value = window.config.rotationX;
        
        document.getElementById('rotationY').value = window.config.rotationY;
        document.getElementById('rotationYValue').textContent = window.config.rotationY + '째';
        document.getElementById('rotationYNumber').value = window.config.rotationY;
        
        document.getElementById('rotationZ').value = window.config.rotationZ;
        document.getElementById('rotationZValue').textContent = window.config.rotationZ + '째';
        document.getElementById('rotationZNumber').value = window.config.rotationZ;
        
        document.getElementById('autoRotate').checked = window.config.autoRotate;
        
        document.getElementById('rotationSpeed').value = window.config.rotationSpeed;
        document.getElementById('rotationSpeedValue').textContent = window.config.rotationSpeed;
        document.getElementById('rotationSpeedNumber').value = window.config.rotationSpeed;
        
        // Animation
        document.getElementById('maxZoom').value = window.config.maxZoom;
        document.getElementById('maxZoomValue').textContent = window.config.maxZoom;
        document.getElementById('maxZoomNumber').value = window.config.maxZoom;
        
        document.getElementById('zoomSpeed').value = window.config.zoomSpeed;
        document.getElementById('zoomSpeedValue').textContent = window.config.zoomSpeed;
        document.getElementById('zoomSpeedNumber').value = window.config.zoomSpeed;
        
        document.getElementById('growthStart').value = window.config.growthStart;
        document.getElementById('growthStartValue').textContent = window.config.growthStart + '%';
        document.getElementById('growthStartNumber').value = window.config.growthStart;
        
        document.getElementById('growthEnd').value = window.config.growthEnd;
        document.getElementById('growthEndValue').textContent = window.config.growthEnd + '%';
        document.getElementById('growthEndNumber').value = window.config.growthEnd;
        
        // Colors
        const baseColorHex = rgbToHex(window.config.baseColor[0], window.config.baseColor[1], window.config.baseColor[2]);
        document.getElementById('baseColor').value = baseColorHex;
        document.querySelector('#baseColor + .color-preview').style.backgroundColor = baseColorHex;
        document.getElementById('baseColorHex').textContent = baseColorHex.toUpperCase();
        
        const brandColorHex = rgbToHex(window.config.brandColor[0], window.config.brandColor[1], window.config.brandColor[2]);
        document.getElementById('brandColor').value = brandColorHex;
        document.querySelector('#brandColor + .color-preview').style.backgroundColor = brandColorHex;
        document.getElementById('brandColorHex').textContent = brandColorHex.toUpperCase();
        
        document.getElementById('fillType').value = window.config.fillType;
        
        document.getElementById('strokeWeight').value = window.config.strokeWeight;
        document.getElementById('strokeWeightValue').textContent = window.config.strokeWeight;
        
        // Position and Size
        document.getElementById('xPosition').value = window.config.xPosition;
        document.getElementById('xPositionValue').textContent = window.config.xPosition + '%';
        document.getElementById('xPositionNumber').value = window.config.xPosition;
        
        document.getElementById('yPosition').value = window.config.yPosition;
        document.getElementById('yPositionValue').textContent = window.config.yPosition + '%';
        document.getElementById('yPositionNumber').value = window.config.yPosition;
        
        document.getElementById('zPosition').value = window.config.zPosition;
        document.getElementById('zPositionValue').textContent = window.config.zPosition;
        document.getElementById('zPositionNumber').value = window.config.zPosition;
        
        document.getElementById('autoMove').checked = window.config.autoMove;
        
        document.getElementById('moveSpeed').value = window.config.moveSpeed;
        document.getElementById('moveSpeedValue').textContent = window.config.moveSpeed;
        document.getElementById('moveSpeedNumber').value = window.config.moveSpeed;
        
        document.getElementById('startingSize').value = window.config.startingSize;
        document.getElementById('startingSizeValue').textContent = window.config.startingSize;
        document.getElementById('startingSizeNumber').value = window.config.startingSize;
      }
      
      // Helper function to convert RGB to hex
      function rgbToHex(r, g, b) {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      }
      
      // Function to export the tree as SVG
      function exportTreeAsSVG() {
        const statusElement = document.getElementById('exportStatus');
        statusElement.textContent = "Generating SVG...";
        
        // Create a new SVG element
        const svgNS = "http://www.w3.org/2000/svg";
        const svgElement = document.createElementNS(svgNS, "svg");
        
        // Set the dimensions of the SVG
        const exportQuality = document.getElementById('exportQuality').value;
        const scaleFactor = exportQuality === 'high' ? 2 : 1;
        const width = p.width * scaleFactor;
        const height = p.height * scaleFactor;
        
        svgElement.setAttribute("width", width);
        svgElement.setAttribute("height", height);
        svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);
        
        // Add metadata for Adobe Illustrator
        const metadataElement = document.createElementNS(svgNS, "metadata");
        metadataElement.textContent = "Created with BoxcurveTree Generator - Compatible with Adobe Illustrator";
        svgElement.appendChild(metadataElement);
        
        // Create a collection to hold all the shapes
        const treeGroup = document.createElementNS(svgNS, "g");
        treeGroup.setAttribute("id", "boxcurve-tree");
        treeGroup.setAttribute("transform", `translate(${width/2}, ${height/2})`);
        svgElement.appendChild(treeGroup);
        
        // Track original squares drawn count to compare
        const originalSquaresDrawn = squaresDrawn;
        
        // Use a custom renderer to capture the tree structure
        const svgRenderer = {
          shapes: [],
          
          // Add a rectangle to the SVG output
          addRect: function(x, y, z, width, height, depth, fillColor, strokeColor, isFrontOrBack) {
            if ((window.config.fillType === 'sidewalls' && isFrontOrBack) || depth === 0) {
              return; // Skip front/back faces for sidewalls only mode
            }
            
            const rect = document.createElementNS(svgNS, "rect");
            
            // Apply the same transformations as in the canvas
            const transformStr = this.getTransformString(x, y, z);
            rect.setAttribute("transform", transformStr);
            
            rect.setAttribute("x", -width/2);
            rect.setAttribute("y", -height/2);
            rect.setAttribute("width", width);
            rect.setAttribute("height", height);
            
            // Apply styles
            if (fillColor) {
              rect.setAttribute("fill", `rgb(${fillColor[0]}, ${fillColor[1]}, ${fillColor[2]})`);
            } else {
              rect.setAttribute("fill", "none");
            }
            
            if (strokeColor) {
              rect.setAttribute("stroke", `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`);
              rect.setAttribute("stroke-width", window.config.strokeWeight * scaleFactor);
            }
            
            this.shapes.push(rect);
          },
          
          // Get SVG transform string for positioning
          getTransformString: function(x, y, z) {
            const xPos = p.map(window.config.xPosition, 0, 100, -p.width/2, p.width/2) * scaleFactor;
            const yPos = p.map(window.config.yPosition, 0, 100, -p.height/2, p.height/2) * scaleFactor;
            
            let transformStr = `translate(${x * scaleFactor * zoomFactor}, ${y * scaleFactor * zoomFactor})`;
            
            // Apply rotations
            if (window.config.rotationX !== 0) {
              transformStr += ` rotateX(${window.config.rotationX})`;
            }
            if (window.config.rotationY !== 0) {
              transformStr += ` rotateY(${window.config.rotationY})`;
            }
            if (window.config.rotationZ !== 0) {
              transformStr += ` rotateZ(${window.config.rotationZ})`;
            }
            
            return transformStr;
          }
        };
        
        // Custom function to draw the tree for SVG export
        function exportBoxcurveTree(x, y, size, maxDepth, svgRenderer) {
          // Mimic the drawBoxcurveTree function logic
          const p1 = [-size / 2, -size / 2];
          const p2 = [size / 2, -size / 2];
          exportGenerateTree([p1, p2], 0, maxDepth, svgRenderer);
        }
        
        function exportGenerateTree(coordSet, depth, maxDepth, svgRenderer) {
          if (depth >= maxDepth) return;
          
          const p1 = coordSet[0];
          const p2 = coordSet[1];
          
          // Draw the cube
          const cubeCoordSet = exportDrawCube(p1, p2, depth, svgRenderer);
          
          // Calculate next depth based on scaling factor
          const size = p.dist(p1[0], p1[1], p2[0], p2[1]);
          
          // Draw the triangle connection
          const triangleCoordSets = exportDrawTriangle(cubeCoordSet[0], cubeCoordSet[1], depth, window.config.branchAngle, false);
          
          // Continue recursion
          for (let nextCoordSet of triangleCoordSets) {
            exportGenerateTree(nextCoordSet, depth + 1, maxDepth, svgRenderer);
          }
        }
        
        function exportDrawCube(p1, p2, depth, svgRenderer) {
          // Calculate the square dimensions
          const p1_to_p2 = [p1[0] - p2[0], p1[1] - p2[1]];
          const p1_to_p4 = [-p1_to_p2[1], p1_to_p2[0]];
          
          const p3 = [p2[0] + p1_to_p4[0], p2[1] + p1_to_p4[1]];
          const p4 = [p1[0] + p1_to_p4[0], p1[1] + p1_to_p4[1]];
          
          // Calculate width and height based on points
          const width = Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
          const height = width; // Square

          // Get style from original renderer
          const style = getStyle(depth, "cube", 0);
          
          // Calculate cube center
          const centerX = (p1[0] + p2[0] + p3[0] + p4[0]) / 4;
          const centerY = (p1[1] + p2[1] + p3[1] + p4[1]) / 4;
          
          // Calculate actual depth based on settings
          let actualDepth = window.config.pixelDepth;
          if (window.config.depthByLevel) {
            actualDepth = window.config.pixelDepth * (1.0 - (depth / window.config.maxDepth) * 0.5);
          }
          
          // Calculate lighting effect
          let shadeFactor = 1.0;
          if (window.config.enableLighting) {
            // Simplified lighting calculation for front face
            const lightX = p.radians(window.config.lightAngleX);
            const lightY = p.radians(window.config.lightAngleY);
            const dotProduct = Math.cos(lightY) * Math.cos(lightX);
            const lightIntensityFactor = window.config.lightIntensity / 100;
            shadeFactor = 0.3 + 0.7 * Math.max(0, dotProduct) * lightIntensityFactor;
          }
          
          // Apply lighting to colors
          let fillColor = null;
          if (style.fill) {
            fillColor = [
              Math.round(style.fill[0] * shadeFactor),
              Math.round(style.fill[1] * shadeFactor),
              Math.round(style.fill[2] * shadeFactor)
            ];
          }
          
          // Draw front face
          svgRenderer.addRect(centerX, centerY, 0, width, height, 0, fillColor, style.outline, true);
          
          // Draw side faces with depth
          if (actualDepth > 0) {
            const backZ = -actualDepth;
            const sideShadeFactor = shadeFactor * 0.8;
            
            // Side faces with adjusted colors for lighting
            let sideFillColor = null;
            if (style.fill) {
              sideFillColor = [
                Math.round(style.fill[0] * sideShadeFactor),
                Math.round(style.fill[1] * sideShadeFactor),
                Math.round(style.fill[2] * sideShadeFactor)
              ];
            }
            
            // Add side faces - simplified for SVG export
            svgRenderer.addRect(centerX - width/2, centerY, backZ/2, actualDepth, height, actualDepth, sideFillColor, style.outline, false);
            svgRenderer.addRect(centerX + width/2, centerY, backZ/2, actualDepth, height, actualDepth, sideFillColor, style.outline, false);
            svgRenderer.addRect(centerX, centerY - height/2, backZ/2, width, actualDepth, actualDepth, sideFillColor, style.outline, false);
            svgRenderer.addRect(centerX, centerY + height/2, backZ/2, width, actualDepth, actualDepth, sideFillColor, style.outline, false);
            
            // Back face
            const backShadeFactor = shadeFactor * 0.7;
            let backFillColor = null;
            if (style.fill) {
              backFillColor = [
                Math.round(style.fill[0] * backShadeFactor),
                Math.round(style.fill[1] * backShadeFactor),
                Math.round(style.fill[2] * backShadeFactor)
              ];
            }
            
            svgRenderer.addRect(centerX, centerY, backZ, width, height, actualDepth, backFillColor, style.outline, true);
          }
          
          return [p3, p4];
        }
        
        function exportDrawTriangle(p1, p2, depth, angle, mirror) {
          // Same logic as drawTriangle
          let angle1 = p.PI * ((90 - angle) / 180);
          let angle2 = p.PI * (angle / 180);
          
          if (mirror) {
            [angle1, angle2] = [angle2, angle1];
          }
          
          const angle3 = p.PI - angle1 - angle2;
          
          const p1_to_p2 = [p2[0] - p1[0], p2[1] - p1[1]];
          const length_p1_to_p2 = Math.sqrt(p1_to_p2[0] * p1_to_p2[0] + p1_to_p2[1] * p1_to_p2[1]);
          const length_p1_to_p3 = length_p1_to_p2 * Math.sin(angle2) / Math.sin(angle3);
          
          const x = p1_to_p2[0];
          const y = p1_to_p2[1];
          
          const equation_1 = p1[0] * x + p1[1] * y + length_p1_to_p3 * length_p1_to_p2 * Math.cos(angle1);
          const equation_2 = p2[1] * x - p2[0] * y + length_p1_to_p3 * length_p1_to_p2 * Math.sin(angle1);
          
          const factor = 1 / (length_p1_to_p2 * length_p1_to_p2);
          const x3 = factor * (x * equation_1 - y * equation_2);
          const y3 = factor * (y * equation_1 + x * equation_2);
          
          const p3 = [x3, y3];
          
          return [[p3, p1], [p2, p3]];
        }
        
        // Generate the tree for SVG
        exportBoxcurveTree(0, 0, window.config.startingSize * scaleFactor, currentDepth, svgRenderer);
        
        // Add all the shapes to the SVG group
        svgRenderer.shapes.forEach(shape => {
          treeGroup.appendChild(shape);
        });
        
        // Convert SVG to string
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgElement);
        
        // Create a Blob containing the SVG data
        const blob = new Blob([svgString], {type: 'image/svg+xml'});
        
        // Create a URL for the blob
        const url = URL.createObjectURL(blob);
        
        // Create a download link
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = `boxcurve_tree_${new Date().toISOString().slice(0,10)}.svg`;
        
        // Trigger the download
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        
        // Release the URL
        URL.revokeObjectURL(url);
        
        // Update status
        statusElement.textContent = `SVG exported with ${svgRenderer.shapes.length} shapes!`;
        setTimeout(() => {
          statusElement.textContent = "Ready for export";
        }, 3000);
      }
    }
  </script>
</body>
</html>